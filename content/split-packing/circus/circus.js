// Generated by CoffeeScript 1.10.0
(function() {
  var Circle, Color, Instance, Mouse, Rect, Triangle, Vertex, a, active, canvas, ctx, download, draw, drawLoop, exportTikz, height, helpers, instanceHeight, instanceScale, instances, k, len, object, objects, r, rand, rebuild, rebuildAll, ref, ref1, ref2, scrollContainer, scrollInstance, scrollObject, scrollStrategy, shape, shapeNames, shapes, strategies, strategy, targetArea, width, yShift;

  Number.prototype.mod = function(n) {
    return ((this % n) + n) % n;
  };

  rand = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  };

  r = function(a) {
    return Math.sqrt(a / Math.PI);
  };

  yShift = 550;

  instanceHeight = 50;

  instanceScale = 1;

  Color = (function() {
    function Color(h1, s1, l1, a3) {
      this.h = h1;
      this.s = s1;
      this.l = l1;
      this.a = a3;
    }

    Color.rand = function() {
      return new Color(rand(0, 360), 100, rand(20, 40), 0.8);
    };

    Color.prototype.string = function() {
      return "hsla(" + this.h + "," + this.s + "%," + this.l + "%," + this.a + ")";
    };

    Color.prototype.gray = function() {
      return new Color(this.h, 0, this.l, this.a);
    };

    return Color;

  })();

  Instance = (function() {
    function Instance(circles) {
      this.circles = circles != null ? circles : [];
      this.visible = false;
      this.mina = 0;
    }

    Instance.prototype.clone = function() {
      var c, circle, i, k, len, ref;
      i = new Instance;
      ref = this.circles;
      for (k = 0, len = ref.length; k < len; k++) {
        circle = ref[k];
        c = new Circle(circle.a);
        c.color = circle.color;
        i.push(c);
      }
      return i;
    };

    Instance.rand = function() {
      return new Instance((function() {
        var k, ref, results;
        results = [];
        for (k = 0, ref = rand(3, 100); 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--) {
          results.push(new Circle(Math.pow(rand(10, 2000), 5)));
        }
        return results;
      })());
    };

    Instance.prototype.length = function() {
      return this.circles.length;
    };

    Instance.prototype.sum = function(from, to) {
      if (from == null) {
        from = 0;
      }
      if (to == null) {
        to = -1;
      }
      return this.circles.slice(from, +to + 1 || 9e9).reduce((function(a, b) {
        return a + b.a;
      }), 0);
    };

    Instance.prototype.width = function() {
      return canvas.width;
    };

    Instance.prototype.height = function() {
      return this.sum() / this.width();
    };

    Instance.prototype.push = function(c) {
      return this.circles.push(c);
    };

    Instance.prototype.normalize = function(target_sum) {
      var circle, current_sum, k, len, ref, results;
      current_sum = this.sum();
      ref = this.circles;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        circle = ref[k];
        results.push(circle.a *= target_sum / current_sum);
      }
      return results;
    };

    Instance.prototype.draw = function() {
      var circle, k, len, ref, results;
      ref = this.circles;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        circle = ref[k];
        results.push(circle.draw(circle.pos));
      }
      return results;
    };

    Instance.prototype.tikz = function() {
      var circle, k, len, ref, text;
      text = "";
      ref = this.circles;
      for (k = 0, len = ref.length; k < len; k++) {
        circle = ref[k];
        text += circle.tikz();
      }
      return text;
    };

    Instance.prototype.draw3 = function() {
      var circle, k, len, ref, results, w, x;
      x = 0;
      ref = this.circles;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        circle = ref[k];
        if (this.visible) {
          ctx.fillStyle = circle.color.string();
        } else {
          ctx.fillStyle = circle.color.gray().string();
        }
        w = circle.a / this.sum() * this.width();
        ctx.fillRect(x, 0, w, instanceHeight * instanceScale);
        results.push(x += w);
      }
      return results;
    };

    Instance.prototype.clearMinA = function() {
      var circle, k, len, ref, results;
      ref = this.circles;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        circle = ref[k];
        results.push(circle.mina = 0);
      }
      return results;
    };

    Instance.prototype.sort = function() {
      return this.sortedCircles = this.circles.slice().sort(function(a, b) {
        return b.a - a.a;
      });
    };

    Instance.prototype.split = function(f) {
      var buckets, circs, i, j, minFill, minI, mina, n, rad, ref, sum, x;
      if (f == null) {
        f = [1, 1];
      }
      circs = (ref = this.sortedCircles) != null ? ref : this.circles;
      n = f.length;
      buckets = Array.apply(null, Array(n)).map(function() {
        return new Instance;
      });
      j = 0;
      while (j < circs.length) {
        x = circs[j].a;
        minFill = 999999999999999;
        minI = 0;
        i = 0;
        while (i < n) {
          sum = buckets[i].sum();
          if (sum / f[i] < minFill) {
            minFill = sum / f[i];
            minI = i;
          }
          i++;
        }
        buckets[minI].push(circs[j]);
        j++;
      }
      minFill = 999999999999999;
      minI = 0;
      i = 0;
      while (i < n) {
        sum = buckets[i].sum();
        if (sum / f[i] < minFill) {
          minFill = sum / f[i];
          minI = i;
        }
        i++;
      }
      rad = buckets[minI].sum() / f[minI];
      i = 0;
      while (i < f.length) {
        mina = buckets[i].sum() - (f[i] * rad);
        if (2 * mina > buckets[i].sum() && object !== "circle") {
          mina = buckets[i].sum();
        }
        buckets[i].mina = Math.max(mina, this.mina);
        j = 0;
        while (j < buckets[i].length()) {
          if (mina > buckets[i].circles[j].mina || buckets[i].circles[j].mina === void 0) {
            buckets[i].circles[j].mina = mina;
          }
          j++;
        }
        i++;
      }
      return buckets;
    };

    Instance.prototype.split3 = function(f) {
      var buckets, circs, i, j, n, nowa, ref, total, totalf;
      circs = (ref = this.sortedCircles) != null ? ref : this.circles;
      totalf = f.reduce(function(a, b) {
        return a + b;
      });
      total = circs.sum();
      n = f.length;
      buckets = Array.apply(null, Array(n)).map(function() {
        return new Instance;
      });
      i = 0;
      nowa = false;
      if (f[0] < f[1]) {
        i = 0;
      } else {
        i = 1;
      }
      j = 0;
      while (j < circs.length) {
        if (buckets[i].sum() >= f[i] / totalf * total) {
          i = (i + 1) % n;
        }
        buckets[i].push(circs[j]);
        j++;
      }
      return buckets;
    };

    Instance.prototype.split2 = function(f) {
      var buckets, circle, circs, i, k, len, n, ref, total, totalf;
      circs = (ref = this.sortedCircles) != null ? ref : this.circles;
      totalf = f.reduce(function(a, b) {
        return a + b;
      });
      total = circs.sum();
      n = f.length;
      buckets = Array.apply(null, Array(n)).map(function() {
        return new Instance;
      });
      i = 0;
      for (k = 0, len = circs.length; k < len; k++) {
        circle = circs[k];
        if (i === 0 && buckets[i].sum() + circle.a / 2 > f[i] / totalf * total) {
          i++;
        }
        buckets[i].push(circle);
      }
      return buckets;
    };

    return Instance;

  })();

  Circle = (function() {
    function Circle(a3) {
      this.a = a3;
      this.mina = 0;
      this.color = Color.rand();
      this.pos = [0, 0];
      this.rot = 0;
      this.flip = false;
      this.vertices = [];
    }

    Circle.prototype.draw = function(pos) {
      var ang, c, i, k, l, len, m, p, pp, ref, t, x;
      ctx.fillStyle = this.color.string();
      ctx.beginPath();
      switch (object) {
        case "circle":
          ctx.arc(this.pos[0], this.pos[1], r(this.a), 0, 2 * Math.PI);
          break;
        case "octagon":
          l = r(this.a) / Math.cos(Math.PI / 8);
          p = this.pos.add([l, 0].rot(Math.PI / 8 + this.rot));
          ctx.moveTo(p[0], p[1]);
          for (i = k = 1; k <= 7; i = ++k) {
            pp = this.pos.add([l, 0].rot(Math.PI / 8 + i * Math.PI / 4 + this.rot));
            ctx.lineTo(pp[0], pp[1]);
          }
          ctx.lineTo(p[0], p[1]);
          break;
        case "square":
          l = (1 + Math.sqrt(2)) * r(this.a) / 2;
          x = r(this.a) / 2 * (Math.sqrt(2) - 1);
          pp = this.pos.add([0, -x].rot(this.rot)).add([l, 0].rot(this.rot));
          ctx.moveTo(pp[0], pp[1]);
          ref = [Math.PI / 2, Math.PI, Math.PI / 2 * 3];
          for (m = 0, len = ref.length; m < len; m++) {
            ang = ref[m];
            pp = this.pos.add([0, -x].rot(this.rot)).add([l, 0].rot(ang + this.rot));
            ctx.lineTo(pp[0], pp[1]);
          }
          break;
        case "ruby":
          t = new Triangle([this.pos.add([0, -Math.sqrt(2) * r(this.a)].rot(this.rot)), this.pos.add([-(Math.sqrt(2) + 1) * r(this.a), r(this.a)].rot(this.rot)), this.pos.add([(Math.sqrt(2) + 1) * r(this.a), r(this.a)].rot(this.rot))]);
          t.mina = this.a;
          t.color = this.color;
          t.flip = this.flip;
          t.rotateLargestAngleUp();
          t.drawShape();
      }
      ctx.fill();
      if (false) {
        c = new Circle(this.mina);
        c.pos = this.pos;
        c.rot = this.rot;
        c.flip = this.flip;
        c.color = this.color;
        return c.draw();
      }
    };

    Circle.prototype.tikz = function() {
      var ang, i, k, l, len, m, p, pp, ref, t, text, x;
      text = "\\draw[filled]";
      switch (object) {
        case "circle":
          text += " (" + this.pos[0] + "," + (-this.pos[1]) + ") circle (" + r(this.a) + ");\n";
          break;
        case "octagon":
          l = r(this.a) / Math.cos(Math.PI / 8);
          p = this.pos.add([l, 0].rot(Math.PI / 8 + this.rot));
          text += " (" + p[0] + "," + (-p[1]) + ")";
          for (i = k = 1; k <= 7; i = ++k) {
            pp = this.pos.add([l, 0].rot(Math.PI / 8 + i * Math.PI / 4 + this.rot));
            text += " -- (" + pp[0] + "," + (-pp[1]) + ")";
          }
          text += " -- cycle;\n";
          break;
        case "square":
          l = (1 + Math.sqrt(2)) * r(this.a) / 2;
          x = r(this.a) / 2 * (Math.sqrt(2) - 1);
          pp = this.pos.add([0, -x].rot(this.rot)).add([l, 0].rot(this.rot));
          text += " (" + pp[0] + "," + (-pp[1]) + ")";
          ref = [Math.PI / 2, Math.PI, Math.PI / 2 * 3];
          for (m = 0, len = ref.length; m < len; m++) {
            ang = ref[m];
            pp = this.pos.add([0, -x].rot(this.rot)).add([l, 0].rot(ang + this.rot));
            text += " -- (" + pp[0] + "," + (-pp[1]) + ")";
          }
          text += " -- cycle;\n";
          break;
        case "ruby":
          t = new Triangle([this.pos.add([0, -Math.sqrt(2) * r(this.a)].rot(this.rot)), this.pos.add([-(Math.sqrt(2) + 1) * r(this.a), r(this.a)].rot(this.rot)), this.pos.add([(Math.sqrt(2) + 1) * r(this.a), r(this.a)].rot(this.rot))]);
          t.flip = this.flip;
          t.mina = this.a;
          t.rotateLargestAngleUp();
          text += t.tikzShape();
      }
      return text;
    };

    Circle.prototype.pack = function(instance) {
      var a, ang, b, c, circ, circleArea, circs, endAng, i, k, pos, prevRingArea, ref, ringArea, stopAng;
      circs = instance.circles.slice().sort(function(a, b) {
        return a.a - b.a;
      });
      circs[0].pos = this.pos.add([r(this.a) - r(circs[0].a), 0]);
      stopAng = -Math.asin(r(circs[0].a) / (r(this.a) - r(circs[0].a)));
      if (circs.length > 1) {
        ang = 0;
        circleArea = 0;
        for (i = k = 1, ref = circs.length - 1; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          a = r(circs[i - 1].a);
          b = r(circs[i].a);
          c = r(this.a);
          ang += Math.acos(-(Math.pow(a + b, 2) - Math.pow(c - a, 2) - Math.pow(c - b, 2)) / (2 * (c - a) * (c - b)));
          if (i === 1) {
            prevRingArea = 0;
          } else {
            prevRingArea = Math.PI * (Math.pow(r(this.a), 2) - Math.pow(r(this.a) - r(circs[i - 1].a) * 2, 2));
          }
          ringArea = Math.PI * (Math.pow(r(this.a), 2) - Math.pow(r(this.a) - r(circs[i].a) * 2, 2));
          if (isNaN(ang)) {
            pos = this.pos;
          } else {
            pos = this.pos.add([c - b, 0].rot(-ang));
            endAng = ang + Math.asin(r(circs[i].a) / (r(this.a) - r(circs[i].a)));
            if (i > 1 && (endAng > stopAng + 2 * Math.PI || (circleArea / prevRingArea >= 1 / 2 && (circleArea + circs[i].a) / ringArea < 1 / 2))) {
              circ = new Circle(Math.PI * Math.pow(c - 2 * a, 2));
              circ.pos = this.pos;
              circ.pack(new Instance(circs.slice(i)));
              break;
            }
          }
          circs[i].pos = pos;
          circleArea += circs[i].a;
        }
      }
      return [];
    };

    Circle.prototype.cover = function(instance) {
      return [];
    };

    Circle.prototype.packArea = function() {
      return 2 * Math.PI * Math.pow(r(this.a) / 2, 2);
    };

    Circle.prototype.coverArea = function() {
      return 9 / 4 * this.a;
    };

    return Circle;

  })();

  Vertex = (function() {
    function Vertex(pos1) {
      this.pos = pos1;
    }

    return Vertex;

  })();

  Triangle = (function() {
    function Triangle(vertex_coordinates, mina) {
      var coordinate;
      if (mina == null) {
        mina = 0;
      }
      this.vertices = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = vertex_coordinates.length; k < len; k++) {
          coordinate = vertex_coordinates[k];
          results.push(new Vertex(coordinate));
        }
        return results;
      })();
      this.shift = [0, 0];
      this.color = Color.rand();
      this.mina = mina;
      this.flip = false;
    }

    Triangle.prototype.draw = function() {
      ctx.fillStyle = this.color.string();
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      this.drawShape();
      return ctx.fill();
    };

    Triangle.prototype.drawHelper = function() {
      ctx.strokeStyle = "black";
      ctx.lineWidth = 0.3;
      ctx.beginPath();
      this.drawShape();
      return ctx.stroke();
    };

    Triangle.prototype.drawShape = function() {
      var da, db, dc, k, l, len, p1, p2, p3, p4, p5, p6, ref, vertex, x;
      if (object !== "circle") {
        l = 2 * (1 + Math.sqrt(2)) * (Math.sqrt(4 * Math.sqrt(2) - 4) - 1) * Math.sqrt(2 / ((4 * Math.sqrt(2) - 4) * Math.PI)) * Math.sqrt(this.mina);
        x = Math.sqrt(2) * l / (1 / Math.tan(this.beta() / 2) + 1);
        if (this.flip === null || !this.flip) {
          p1 = this.B().add(this.a().nor().mul(l));
          p2 = p1.add(this.c().nor().rot(Math.PI / 2).mul(x));
          p3 = this.B().add(this.c().nor().mul(-l));
        } else {
          p1 = p2 = p3 = this.B();
        }
        if (this.flip === null || this.flip) {
          p4 = this.A().add(this.c().nor().mul(l));
          p6 = this.A().add(this.b().nor().mul(-l));
          p5 = p6.add(this.c().nor().rot(Math.PI / 2).mul(x));
        } else {
          p4 = p5 = p6 = this.A();
        }
        ctx.moveTo(this.C()[0], this.C()[1]);
        ref = [p1, p2, p3, p4, p5, p6];
        for (k = 0, len = ref.length; k < len; k++) {
          vertex = ref[k];
          ctx.lineTo(vertex[0], vertex[1]);
        }
        return ctx.lineTo(this.C()[0], this.C()[1]);
      } else {
        da = r(this.mina) / Math.tan(this.alpha() / 2);
        db = r(this.mina) / Math.tan(this.beta() / 2);
        dc = r(this.mina) / Math.tan(this.gamma() / 2);
        p1 = this.A().add(this.c().nor().mul(da));
        p2 = this.B().add(this.c().nor().mul(-db));
        p3 = this.B().add(this.a().nor().mul(db));
        p4 = this.C().add(this.a().nor().mul(-dc));
        p5 = this.C().add(this.b().nor().mul(dc));
        p6 = this.A().add(this.b().nor().mul(-da));
        ctx.moveTo(p1[0], p1[1]);
        ctx.lineTo(p2[0], p2[1]);
        ctx.arcTo(this.B()[0], this.B()[1], this.C()[0], this.C()[1], r(this.mina));
        ctx.lineTo(p3[0], p3[1]);
        ctx.lineTo(p4[0], p4[1]);
        ctx.arcTo(this.C()[0], this.C()[1], this.A()[0], this.A()[1], r(this.mina));
        ctx.lineTo(p5[0], p5[1]);
        ctx.lineTo(p6[0], p6[1]);
        return ctx.arcTo(this.A()[0], this.A()[1], this.B()[0], this.B()[1], r(this.mina));
      }
    };

    Triangle.prototype.tikzShape = function() {
      var da, db, dc, k, l, len, p1, p2, p3, p4, p5, p6, ref, text, vertex, x;
      text = "";
      if (object !== "circle") {
        l = 2 * (1 + Math.sqrt(2)) * (Math.sqrt(4 * Math.sqrt(2) - 4) - 1) * Math.sqrt(2 / ((4 * Math.sqrt(2) - 4) * Math.PI)) * Math.sqrt(this.mina);
        x = Math.sqrt(2) * l / (1 / Math.tan(this.beta() / 2) + 1);
        if (this.flip === null || !this.flip) {
          p1 = this.B().add(this.a().nor().mul(l));
          p2 = p1.add(this.c().nor().rot(Math.PI / 2).mul(x));
          p3 = this.B().add(this.c().nor().mul(-l));
        } else {
          p1 = p2 = p3 = this.B();
        }
        if (this.flip === null || this.flip) {
          p4 = this.A().add(this.c().nor().mul(l));
          p6 = this.A().add(this.b().nor().mul(-l));
          p5 = p6.add(this.c().nor().rot(Math.PI / 2).mul(x));
        } else {
          p4 = p5 = p6 = this.A();
        }
        text += " (" + this.C()[0] + "," + (-this.C()[1]) + ")";
        ref = [p1, p2, p3, p4, p5, p6];
        for (k = 0, len = ref.length; k < len; k++) {
          vertex = ref[k];
          text += " -- (" + vertex[0] + "," + (-vertex[1]) + ")";
        }
        text += " -- cycle;\n";
      } else {
        da = r(this.mina) / Math.tan(this.alpha() / 2);
        db = r(this.mina) / Math.tan(this.beta() / 2);
        dc = r(this.mina) / Math.tan(this.gamma() / 2);
        p1 = this.A().add(this.c().nor().mul(da));
        p2 = this.B().add(this.c().nor().mul(-db));
        p3 = this.B().add(this.a().nor().mul(db));
        p4 = this.C().add(this.a().nor().mul(-dc));
        p5 = this.C().add(this.b().nor().mul(dc));
        p6 = this.A().add(this.b().nor().mul(-da));
        text += " (" + p1[0] + "," + (-p1[1]) + ")";
        text += " -- (" + p2[0] + "," + (-p2[1]) + ")";
        text += " arc (" + Math.atan2(-this.c().rot(Math.PI / 2)[1], this.c().rot(Math.PI / 2)[0]) * 180 / Math.PI + ":" + (Math.atan2(-this.c().rot(Math.PI / 2)[1], this.c().rot(Math.PI / 2)[0]) * 180 / Math.PI + 180 - this.beta() * 180 / Math.PI) + ":" + r(this.mina) + ")";
        text += " (" + p3[0] + "," + (-p3[1]) + ")";
        text += " -- (" + p4[0] + "," + (-p4[1]) + ")";
        text += " arc (" + Math.atan2(-this.a().rot(Math.PI / 2)[1], this.a().rot(Math.PI / 2)[0]) * 180 / Math.PI + ":" + (Math.atan2(-this.a().rot(Math.PI / 2)[1], this.a().rot(Math.PI / 2)[0]) * 180 / Math.PI + 180 - this.gamma() * 180 / Math.PI) + ":" + r(this.mina) + ")";
        text += " -- (" + p5[0] + "," + (-p5[1]) + ")";
        text += " -- (" + p6[0] + "," + (-p6[1]) + ")";
        text += " arc (" + Math.atan2(-this.b().rot(Math.PI / 2)[1], this.b().rot(Math.PI / 2)[0]) * 180 / Math.PI + ":" + (Math.atan2(-this.b().rot(Math.PI / 2)[1], this.b().rot(Math.PI / 2)[0]) * 180 / Math.PI + 180 - this.alpha() * 180 / Math.PI) + ":" + r(this.mina) + ")";
        text += ";\n";
      }
      return text;
    };

    Triangle.prototype.tikzHelper = function() {
      return "\\draw[helper]" + this.tikzShape();
    };

    Triangle.prototype.tikz = function() {
      return "\\draw" + this.tikzShape();
    };

    Triangle.prototype.A = function() {
      return this.vertices[0].pos;
    };

    Triangle.prototype.B = function() {
      return this.vertices[1].pos;
    };

    Triangle.prototype.C = function() {
      return this.vertices[2].pos;
    };

    Triangle.prototype.rotateLargestAngleUp = function() {
      var results;
      results = [];
      while (this.gamma() < Math.max(this.alpha(), this.beta())) {
        results.push(this.vertices = this.vertices.slice(1, this.vertices.length).concat(this.vertices.slice(0, 1)));
      }
      return results;
    };

    Triangle.prototype.rotateSmallestAngleUp = function() {
      var results;
      results = [];
      while (this.gamma() > Math.min(this.alpha(), this.beta())) {
        results.push(this.vertices = this.vertices.slice(1, this.vertices.length).concat(this.vertices.slice(0, 1)));
      }
      return results;
    };

    Triangle.prototype.a = function() {
      return this.C().sub(this.B());
    };

    Triangle.prototype.b = function() {
      return this.A().sub(this.C());
    };

    Triangle.prototype.c = function() {
      return this.B().sub(this.A());
    };

    Triangle.prototype.alpha = function() {
      return Math.acos((-this.c()[0] * this.b()[0] - (this.c()[1] * this.b()[1])) / (this.b().len() * this.c().len()));
    };

    Triangle.prototype.beta = function() {
      return Math.acos((-this.a()[0] * this.c()[0] - (this.a()[1] * this.c()[1])) / (this.c().len() * this.a().len()));
    };

    Triangle.prototype.gamma = function() {
      return Math.PI - this.alpha() - this.beta();
    };

    Triangle.prototype.symmetric = function() {
      return Math.abs(this.alpha() - this.beta()) < 0.01;
    };

    Triangle.prototype.packsRubies = function() {
      return Math.abs(this.a().len() - this.b().len()) < 0.002 * this.a().len() && Math.abs(this.a().len() - this.c().len() / Math.sqrt(2)) < 0.002 * this.a().len();
    };

    Triangle.prototype.pack = function(instance) {
      var D, a, a1, a2, b, buckets, c, f1, f2, flip1, flip2, ref, ref1, ref2, ref3, sum1, sum2, t1, t2, tr1, tr2;
      this.rotateLargestAngleUp();
      this.draw();
      if (instance.length() === 1) {
        instance.circles[0].pos = [(this.a().len() * this.A()[0] + this.b().len() * this.B()[0] + this.c().len() * this.C()[0]) / (this.a().len() + this.b().len() + this.c().len()), (this.a().len() * this.A()[1] + this.b().len() * this.B()[1] + this.c().len() * this.C()[1]) / (this.a().len() + this.b().len() + this.c().len())];
        instance.circles[0].rot = Math.atan2(this.c().rot(0)[1], this.c().rot(0)[0]);
        instance.circles[0].flip = this.flip;
        return [];
      } else {
        D = this.A().add(this.c().nor().mul(Math.cos(this.alpha()) * this.b().len()));
        a1 = (new Triangle([this.A(), D, this.C()])).packArea();
        a2 = (new Triangle([this.B(), this.C(), D])).packArea();
        buckets = instance.split([a1, a2]);
        sum1 = buckets[0].sum();
        sum2 = buckets[1].sum();
        if (this.symmetric()) {
          if ((sum1 < sum2 && !this.flip) || (sum1 > sum2 && this.flip)) {
            ref = [a2, a1], a1 = ref[0], a2 = ref[1];
            ref1 = [sum2, sum1], sum1 = ref1[0], sum2 = ref1[1];
            ref2 = [buckets[1], buckets[0]], buckets[0] = ref2[0], buckets[1] = ref2[1];
          }
        }
        f1 = Math.sqrt(sum1 / a1);
        f2 = Math.sqrt(sum2 / a2);
        a = shape.a().len();
        b = shape.b().len();
        c = shape.c().len();
        if (this.flip) {
          ref3 = [b, a], a = ref3[0], b = ref3[1];
        }
        flip1 = sum1 / sum2 >= 2 * b / (c - b) && this.symmetric();
        flip2 = sum2 / sum1 >= 2 * a / (c - a) && this.symmetric();
        t1 = flip1 ? new Triangle([this.A(), this.A().add(this.c().nor().mul(this.C().sub(this.A()).mul(f1).len())), this.A().add(this.b().nor().mul(-D.sub(this.A()).mul(f1).len()))]) : new Triangle([this.A(), this.A().add(D.sub(this.A()).mul(f1)), this.A().add(this.C().sub(this.A()).mul(f1))]);
        t2 = flip2 ? new Triangle([this.B(), this.B().add(this.a().nor().mul(D.sub(this.B()).mul(f2).len())), this.B().add(this.c().nor().mul(-this.C().sub(this.B()).mul(f2).len()))]) : new Triangle([this.B(), this.B().add(this.C().sub(this.B()).mul(f2)), this.B().add(D.sub(this.B()).mul(f2))]);
        t1.mina = buckets[0].mina;
        t2.mina = buckets[1].mina;
        if (flip1) {
          t1.flip = this.flip;
          tr1 = t1.pack(buckets[0]);
        } else {
          t1.flip = (this.flip === null ? null : !this.flip);
          tr1 = t1.pack(buckets[0]);
        }
        if (flip2) {
          t2.flip = this.flip;
          tr2 = t2.pack(buckets[1]);
        } else {
          t2.flip = (this.flip === null ? null : !this.flip);
          tr2 = t2.pack(buckets[1]);
        }
        return [t1, t2].concat(tr1).concat(tr2);
      }
    };

    Triangle.prototype.pack2 = function(instance) {
      var A2, B2, h, j, l, l2, pos, rad, remaining, required, shift, used, x;
      this.rotateSmallestAngleUp();
      used = 0;
      j = 0;
      h = r(circs[0].a) * 2;
      while (j < circs.length) {
        rad = r(circs[j].a);
        if (j === 0) {
          shift = rad / Math.tan(this.alpha() / 2);
          used = shift + rad;
        } else {
          shift = used + rad;
          required = rad / Math.tan(this.beta() / 2);
          if (shift + required > this.c().len()) {
            l = h / Math.sin(this.alpha());
            l2 = h / Math.sin(this.beta());
            A2 = this.A().add(this.b().nor().mul(-l));
            B2 = this.B().add(this.a().nor().mul(l2));
            remaining = circs.slice(j);
            (new Triangle([A2, B2, this.C()])).pack(new Instance(remaining));
            return;
          } else {
            used = used + 2 * rad;
          }
        }
        x = this.A().add(this.c().nor().mul(shift));
        pos = x.add(this.c().nor().mul(rad).rot(-Math.PI / 2));
        circs[j].pos = pos;
        j++;
      }
      return [];
    };

    Triangle.prototype.cover4 = function(instance) {
      var h;
      instance.normalize(instance.sum() / (1 + 2 * Math.sqrt(2) + 2));
      h = this.pack(instance);
      instance.normalize(instance.sum() * (1 + 2 * Math.sqrt(2) + 2));
      return h;
    };

    Triangle.prototype.cover3 = function(instance) {
      var b, buckets, d1, d2, d3, h, ref, ref1, sum1, sum2, t1, t2, tr1, tr2;
      this.rotateLargestAngleUp();
      this.draw();
      if (instance.length() === 1) {
        instance.circles[0].pos = this.A().add(this.B()).div(2);
        return [];
      } else if (instance.length() > 1) {
        buckets = instance.split([1, 1]);
        sum1 = buckets[0].sum();
        sum2 = buckets[1].sum();
        if (sum1 > sum2) {
          ref = [sum2, sum1], sum1 = ref[0], sum2 = ref[1];
          ref1 = [buckets[1], buckets[0]], buckets[0] = ref1[0], buckets[1] = ref1[1];
        }
        d1 = 2 * Math.sqrt(sum1 / Math.PI);
        d2 = 2 * Math.sqrt(sum2 / Math.PI);
        d3 = this.A().sub(this.B()).len();
        b = d3 - d1 / Math.sqrt(2);
        h = Math.sqrt(Math.pow(d2, 2) - Math.pow(b, 2));
        t1 = new Triangle([this.A(), this.A().add(this.c().nor().mul(d1 / Math.sqrt(2))), this.A().add(this.b().nor().mul(-d1))]);
        tr1 = t1.cover(buckets[0]);
        t2 = new Triangle([this.B(), this.A().add(this.c().nor().mul(d1 / Math.sqrt(2))).add(this.c().nor().mul(h).rot(-Math.PI / 2)), this.A().add(this.c().nor().mul(d1 / Math.sqrt(2)))]);
        tr2 = t2.cover(buckets[1]);
        return [t1, t2].concat(tr1).concat(tr2);
      }
    };

    Triangle.prototype.cover = function(instance) {
      var b, buckets, d1, d2, d3, ref, ref1, sum1, sum2, t1, t2, tr1, tr2;
      this.rotateLargestAngleUp();
      this.draw();
      if (instance.length() === 1) {
        instance.circles[0].pos = this.A().add(this.B()).div(2);
        return [];
      } else if (instance.length() > 1) {
        buckets = instance.split([1, 1]);
        sum1 = buckets[0].sum();
        sum2 = buckets[1].sum();
        if (sum1 > sum2) {
          ref = [sum2, sum1], sum1 = ref[0], sum2 = ref[1];
          ref1 = [buckets[1], buckets[0]], buckets[0] = ref1[0], buckets[1] = ref1[1];
        }
        d1 = 2 * Math.sqrt(sum1 / Math.PI);
        d2 = 2 * Math.sqrt(sum2 / Math.PI);
        d3 = this.A().sub(this.B()).len();
        b = d3 - d1 / Math.sqrt(2);
        t1 = new Triangle([this.A(), this.A().add(this.c().nor().mul(d1 / Math.sqrt(2))), this.A().add(this.b().nor().mul(-d1))]);
        t2 = new Triangle([this.B(), this.B().add(this.a().nor().mul(d2)), this.B().add(this.c().nor().mul(-d2 / Math.sqrt(2)))]);
        tr1 = t1.cover(buckets[0]);
        tr2 = t2.cover(buckets[1]);
        return [t1, t2].concat(tr1).concat(tr2);
      }
    };

    Triangle.prototype.packArea = function() {
      var area, incirclearea, r2, rad, s, twocirclearea;
      this.rotateLargestAngleUp();
      s = (this.a().len() + this.b().len() + this.c().len()) / 2;
      area = Math.sqrt(s * (s - this.a().len()) * (s - this.b().len()) * (s - this.c().len()));
      rad = area / s;
      incirclearea = Math.PI * rad * rad;
      r2 = this.c().len() / (2 + 1 / Math.tan(this.alpha() / 2) + 1 / Math.tan(this.beta() / 2));
      twocirclearea = 2 * Math.PI * r2 * r2;
      if (incirclearea > twocirclearea) {
        return twocirclearea;
      } else {
        return incirclearea;
      }
    };

    Triangle.prototype.coverArea = function() {
      this.rotateLargestAngleUp();
      return Math.PI * Math.pow(this.c().len() / 2, 2);
    };

    return Triangle;

  })();

  Rect = (function() {
    function Rect(w, h) {
      this.vertices = [new Vertex([w / 2, -h / 2])];
      this.color = Color.rand();
    }

    Rect.prototype.w = function() {
      return this.vertices[0].pos[0] * 2;
    };

    Rect.prototype.h = function() {
      return this.vertices[0].pos[1] * -2;
    };

    Rect.prototype.symmetric = function() {
      return false;
    };

    Rect.prototype.draw = function() {
      ctx.fillStyle = this.color.string();
      return ctx.fillRect(-this.w() / 2, -this.h() / 2, this.w(), this.h());
    };

    Rect.prototype.tikz = function() {
      return "\\draw (" + (-this.w() / 2) + "," + (-this.h() / 2) + ") rectangle (" + this.w() / 2 + "," + this.h() / 2 + ");\n";
    };

    Rect.prototype.packArea = function() {
      return Math.min((new Triangle([[0, 0], [this.w(), 0], [this.w(), this.h()]])).packArea() * 2, Math.PI * Math.pow(Math.min(this.w(), this.h()) / 2, 2));
    };

    Rect.prototype.coverArea = function() {
      return (new Triangle([[0, 0], [this.w(), 0], [this.w(), this.h()]])).coverArea() * 2;
    };

    Rect.prototype.pack = function(instance) {
      var a, buckets, f1, f2, ref, ref1, sum1, sum2, t1, t2, tr1, tr2, x;
      if (instance.length() === 1) {
        x = r(instance.circles[0].a);
        instance.circles[0].pos = [-this.w() / 2 + x, -this.h() / 2 + x];
        instance.circles[0].rot = -Math.PI / 4;
        instance.circles[0].flip = null;
        return [];
      } else if (instance.length() > 1) {
        a = (new Triangle([[0, 0], [this.w(), 0], [this.w(), this.h()]])).packArea();
        buckets = instance.split([1, 1]);
        sum1 = buckets[0].sum();
        sum2 = buckets[1].sum();
        if (sum1 < sum2) {
          ref = [sum2, sum1], sum1 = ref[0], sum2 = ref[1];
          ref1 = [buckets[1], buckets[0]], buckets[0] = ref1[0], buckets[1] = ref1[1];
        }
        f1 = Math.sqrt(sum1 / a);
        f2 = Math.sqrt(sum2 / a);
        t1 = new Triangle([[-this.w() / 2, -this.h() / 2], [-this.w() / 2, -this.h() / 2 + this.h() * f1], [-this.w() / 2 + this.w() * f1, -this.h() / 2]]);
        t2 = new Triangle([[this.w() / 2, this.h() / 2], [this.w() / 2, this.h() / 2 - this.h() * f2], [this.w() / 2 - this.w() * f2, this.h() / 2]]);
        t1.mina = buckets[0].mina;
        t2.mina = buckets[1].mina;
        t1.flip = null;
        t2.flip = null;
        tr1 = t1.pack(buckets[0]);
        tr2 = t2.pack(buckets[1]);
        return [t1, t2].concat(tr1).concat(tr2);
      }
    };

    Rect.prototype.packsRubies = function() {
      return Math.abs(this.w() - this.h()) < 0.002 * this.w();
    };

    Rect.prototype.alpha = function() {
      return Math.PI / 2 - this.beta();
    };

    Rect.prototype.beta = function() {
      return Math.atan2(this.h(), this.w());
    };

    Rect.prototype.gamma = function() {
      return Math.PI / 2;
    };

    Rect.prototype.a = function() {
      return [-this.w(), 0];
    };

    Rect.prototype.b = function() {
      return [0, -this.h()];
    };

    Rect.prototype.c = function() {
      return this.vertices[0].pos.mul(2);
    };

    Rect.prototype.cover = function() {
      return [];
    };

    return Rect;

  })();

  draw = function() {
    var helper, instance, k, len, len1, len2, len3, m, q, ref, u, vertex;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    for (k = 0, len = instances.length; k < len; k++) {
      instance = instances[k];
      instance.draw3();
      ctx.translate(0, instanceHeight * instanceScale);
    }
    ctx.restore();
    ctx.save();
    ctx.translate(canvas.width / 2, yShift);
    shape.draw();
    ref = shape.vertices;
    for (m = 0, len1 = ref.length; m < len1; m++) {
      vertex = ref[m];
      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.rect(vertex.pos[0] - 3, vertex.pos[1] - 3, 6, 6);
      ctx.stroke();
    }
    for (q = 0, len2 = instances.length; q < len2; q++) {
      instance = instances[q];
      if (instance.visible) {
        instance.draw();
      }
    }
    if (active && ((active.instance != null) || (active.object.a == null)) && Mouse.didReallyMove) {
      for (u = 0, len3 = helpers.length; u < len3; u++) {
        helper = helpers[u];
        helper.drawHelper();
      }
    }
    return ctx.restore();
  };

  drawLoop = function() {
    requestAnimationFrame(drawLoop);
    if (window.updateCanvas) {
      draw();
      return window.updateCanvas = false;
    }
  };

  Array.prototype.add = function(vector) {
    return [this[0] + vector[0], this[1] + vector[1]];
  };

  Array.prototype.sub = function(vector) {
    return [this[0] - vector[0], this[1] - vector[1]];
  };

  Array.prototype.mul = function(scalar) {
    return [this[0] * scalar, this[1] * scalar];
  };

  Array.prototype.div = function(scalar) {
    return [this[0] / scalar, this[1] / scalar];
  };

  Array.prototype.len = function() {
    return Math.sqrt(this[0] * this[0] + this[1] * this[1]);
  };

  Array.prototype.nor = function() {
    return this.mul(1 / this.len());
  };

  Array.prototype.sum = function() {
    return this.reduce((function(a, b) {
      return a + b.a;
    }), 0);
  };

  Array.prototype.rot = function(theta) {
    return [this[0] * Math.cos(theta) - (this[1] * Math.sin(theta)), this[0] * Math.sin(theta) + this[1] * Math.cos(theta)];
  };

  canvas = document.getElementById("canvas");

  ctx = canvas.getContext("2d");

  active = null;

  shape = null;

  strategy = null;

  object = null;

  helpers = [];

  window.requestAnimationFrame = (ref = (ref1 = (ref2 = window.requestAnimationFrame) != null ? ref2 : window.webkitRequestAnimationFrame) != null ? ref1 : window.mozRequestAnimationFrame) != null ? ref : window.msRequestAnimationFrame;

  window.updateCanvas = true;

  Mouse = {
    pos: [canvas.width / 2, canvas.height / 2],
    down: false,
    didMove: false,
    didReallyMove: false,
    wheel: 0
  };

  canvas.onmousemove = (function(_this) {
    return function(event) {
      var a1, a2, b1, b2, circle, instance, k, len, len1, m, ref3, ref4;
      Mouse.pos = [event.clientX, event.clientY];
      Mouse.didMove = true;
      Mouse.didReallyMove = true;
      if (active !== null) {
        if (active.object != null) {
          active.object.pos = Mouse.pos.sub([canvas.width / 2, yShift]);
          if (active.object.a == null) {
            rebuildAll();
          }
          return window.updateCanvas = true;
        } else if (active.instance != null) {
          if (active.i != null) {
            instance = active.instance;
            a1 = instance.sum(0, active.i);
            a2 = instance.sum(active.i + 1, -1);
            b1 = Mouse.pos[0] * instance.height();
            b2 = instance.sum() - Mouse.pos[0] * instance.height();
            if (b2 < 0 || b1 < 0) {
              active = null;
              return;
            }
            ref3 = instance.circles.slice(0, +active.i + 1 || 9e9);
            for (k = 0, len = ref3.length; k < len; k++) {
              circle = ref3[k];
              circle.a = circle.a * (b1 / a1);
            }
            ref4 = instance.circles.slice(active.i + 1);
            for (m = 0, len1 = ref4.length; m < len1; m++) {
              circle = ref4[m];
              circle.a = circle.a * (b2 / a2);
            }
            rebuild(instance);
            return window.updateCanvas = true;
          } else {
            instanceScale = (Mouse.pos[1] / instances.length) / instanceHeight;
            rebuildAll();
            return window.updateCanvas = true;
          }
        }
      }
    };
  })(this);

  canvas.onmousedown = (function(_this) {
    return function(event) {
      var bestD, c, circle, d, h, i, instance, j, k, len, len1, len2, len3, len4, len5, m, movable, nextX, o, obj, q, ref3, ref4, ref5, ref6, ref7, u, v, x, y, z;
      if (event.which === 1) {
        Mouse.down = true;
        Mouse.didMove = false;
        Mouse.didReallyMove = false;
        if (Mouse.pos[1] > instances.length * instanceHeight * instanceScale - 10 && Mouse.pos[1] < instances.length * instanceHeight * instanceScale + 10) {
          active = {
            instance: instances[instances.length - 1]
          };
        }
        if (active === null) {
          for (i = k = 0, ref3 = instances.length - 1; 0 <= ref3 ? k <= ref3 : k >= ref3; i = 0 <= ref3 ? ++k : --k) {
            instance = instances[i];
            if (Mouse.pos[1] > i * instanceHeight * instanceScale && Mouse.pos[1] <= (i + 1) * instanceHeight * instanceScale) {
              x = 0;
              j = 0;
              ref4 = instance.circles;
              for (m = 0, len = ref4.length; m < len; m++) {
                circle = ref4[m];
                x += circle.a / instance.height();
                if (Math.abs(Mouse.pos[0] - x) < 10) {
                  active = {
                    instance: instance,
                    i: j
                  };
                }
                j++;
              }
              if (active === null) {
                x = 0;
                j = 0;
                ref5 = instance.circles;
                for (q = 0, len1 = ref5.length; q < len1; q++) {
                  circle = ref5[q];
                  nextX = x + circle.a / instance.sum() * instance.width();
                  if (Mouse.pos[0] >= x && Mouse.pos[0] <= nextX) {
                    h = instance.height();
                    circle.a = (Mouse.pos[0] - x) * h;
                    c = new Circle((nextX - Mouse.pos[0]) * h);
                    instance.circles.splice(j + 1, 0, c);
                    active = {
                      instance: instance,
                      i: j
                    };
                    Mouse.didMove = true;
                    rebuild(instance);
                    window.updateCanvas = true;
                    break;
                  }
                  x = nextX;
                  j++;
                }
              }
            }
          }
        }
        if (active === null) {
          movable = shape.vertices;
          for (u = 0, len2 = instances.length; u < len2; u++) {
            instance = instances[u];
            if (instance.visible) {
              movable = movable.concat(instance.circles);
            }
          }
          bestD = 999999999999999;
          for (v = 0, len3 = movable.length; v < len3; v++) {
            obj = movable[v];
            d = Mouse.pos.sub([canvas.width / 2, yShift]).sub(obj.pos).len();
            if (d <= Math.sqrt(((ref6 = obj.a) != null ? ref6 : 200) / Math.PI) && d <= bestD) {
              bestD = d;
              active = {
                object: obj
              };
            }
          }
        }
      }
      if (event.which === 2) {
        movable = [];
        for (y = 0, len4 = instances.length; y < len4; y++) {
          instance = instances[y];
          if (instance.visible) {
            movable = movable.concat(instance.circles);
          }
        }
        bestD = 999999999999999;
        o = null;
        for (z = 0, len5 = movable.length; z < len5; z++) {
          obj = movable[z];
          d = Mouse.pos.sub([canvas.width / 2, yShift]).sub(obj.pos).len();
          if (d <= Math.sqrt(((ref7 = obj.a) != null ? ref7 : 200) / Math.PI) && d <= bestD) {
            bestD = d;
            o = obj;
          }
        }
        if (o !== null) {
          return o.rot += Math.PI / 4;
        }
      }
    };
  })(this);

  canvas.onmouseup = (function(_this) {
    return function(event) {
      var a1, a2;
      if (!Mouse.didMove && active !== null && (active.i != null)) {
        a1 = active.instance.circles[active.i].a;
        a2 = active.instance.circles[active.i + 1].a;
        active.instance.circles[active.i].a = a1 + a2;
        active.instance.circles.splice(active.i + 1, 1);
        rebuild(active.instance);
        window.updateCanvas = true;
      }
      Mouse.down = false;
      active = null;
      return window.updateCanvas = true;
    };
  })(this);

  window.onkeydown = (function(_this) {
    return function(event) {
      if (event.keyCode === 38) {
        scrollInstance(-1);
      }
      if (event.keyCode === 40) {
        scrollInstance(1);
      }
      if (event.keyCode === 49) {
        scrollContainer(1);
      }
      if (event.keyCode === 50) {
        if (shape.packsRubies()) {
          scrollObject(1);
        }
      }
      if (event.keyCode === 51) {
        scrollStrategy(1);
      }
      if (event.keyCode === 52) {
        exportTikz(false);
      }
      if (event.keyCode === 53) {
        return exportTikz(true);
      }
    };
  })(this);

  download = function(filename, text) {
    var element;
    element = document.createElement('a');
    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    return document.body.removeChild(element);
  };

  exportTikz = function(helpers) {
    var helper, i, instance, k, len, len1, m, text;
    if (helpers == null) {
      helpers = true;
    }
    text = shape.tikz();
    if (helpers) {
      for (k = 0, len = helpers.length; k < len; k++) {
        helper = helpers[k];
        text += helper.tikzHelper();
      }
    }
    i = 1;
    for (m = 0, len1 = instances.length; m < len1; m++) {
      instance = instances[m];
      if (instance.visible) {
        text += instance.tikz();
        break;
      }
      i++;
    }
    return download("split-packing-" + i + ".tex", text);
  };

  canvas.onmousewheel = (function(_this) {
    return function(event) {
      var instance, k, len;
      Mouse.wheel += event.wheelDelta;
      for (k = 0, len = instances.length; k < len; k++) {
        instance = instances[k];
        instance.visible = false;
      }
      instances[Math.round(-Mouse.wheel / 500).mod(instances.length)].visible = true;
      return window.updateCanvas = true;
    };
  })(this);

  scrollInstance = (function(_this) {
    return function(delta) {
      var a, i, instance, k, len;
      i = 0;
      for (k = 0, len = instances.length; k < len; k++) {
        instance = instances[k];
        if (instance.visible) {
          a = i;
          instance.visible = false;
        }
        i++;
      }
      instances[(instances.length + a + delta) % instances.length].visible = true;
      return window.updateCanvas = true;
    };
  })(this);

  scrollContainer = (function(_this) {
    return function(delta) {
      var i;
      i = shapes.indexOf(shape);
      shape = shapes[(shapes.length + i + delta) % shapes.length];
      document.getElementById("container").innerHTML = shapeNames[(shapes.length + i + delta) % shapes.length];
      rebuildAll();
      return window.updateCanvas = true;
    };
  })(this);

  scrollStrategy = (function(_this) {
    return function(delta) {
      var i;
      i = strategies.indexOf(strategy);
      strategy = strategies[(strategies.length + i + delta) % strategies.length];
      rebuildAll();
      window.updateCanvas = true;
      return document.getElementById("strategy").innerHTML = strategy;
    };
  })(this);

  scrollObject = (function(_this) {
    return function(delta) {
      var i;
      i = objects.indexOf(object);
      object = objects[(objects.length + i + delta) % objects.length];
      window.updateCanvas = true;
      return document.getElementById("object").innerHTML = object;
    };
  })(this);

  window.onresize = (function(_this) {
    return function(event) {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      return window.updateCanvas = true;
    };
  })(this);

  strategies = ["pack", "manual"];

  strategy = strategies[0];

  objects = ["circle", "octagon", "square", "ruby"];

  object = objects[0];

  instances = [
    Instance.rand(), new Instance((function() {
      var k, len, ref3, results;
      ref3 = [1];
      results = [];
      for (k = 0, len = ref3.length; k < len; k++) {
        a = ref3[k];
        results.push(new Circle(a));
      }
      return results;
    })()), new Instance((function() {
      var k, len, ref3, results;
      ref3 = [1, 1];
      results = [];
      for (k = 0, len = ref3.length; k < len; k++) {
        a = ref3[k];
        results.push(new Circle(a));
      }
      return results;
    })()), new Instance((function() {
      var k, results;
      results = [];
      for (a = k = 1; k <= 50; a = ++k) {
        results.push(new Circle(Math.pow(2, -a)));
      }
      return results;
    })()), new Instance((function() {
      var k, results;
      results = [];
      for (a = k = 50; k >= 1; a = --k) {
        results.push(new Circle(Math.pow(a, 15)));
      }
      return results;
    })()), new Instance((function() {
      var k, results;
      results = [];
      for (a = k = 1; k <= 50; a = ++k) {
        results.push(new Circle(a));
      }
      return results;
    })())
  ];

  instances[0].visible = true;

  shapes = [new Rect(400, 400), new Triangle([[-400, 200], [400, 200], [0, -200]])];

  shapeNames = ["rectangle", "triangle"];

  for (k = 0, len = shapes.length; k < len; k++) {
    shape = shapes[k];
    shape.color = new Color(0, 0, 80, 1);
  }

  width = canvas.width / instances.length;

  height = canvas.height / (1 + shapes.length);

  rebuild = function(instance) {
    var h;
    instance.clearMinA();
    instance.sort();
    if (strategy === "pack") {
      h = shape.pack(instance);
    } else if (strategy === "cover") {
      h = shape.cover(instance);
    } else {
      h = [];
    }
    if (instance.visible) {
      return helpers = h;
    }
  };

  rebuildAll = function() {
    var instance, len1, m, results;
    if (!shape.packsRubies()) {
      while (object !== "circle") {
        scrollObject(1);
      }
    }
    console.log(object);
    results = [];
    for (m = 0, len1 = instances.length; m < len1; m++) {
      instance = instances[m];
      instance.normalize(targetArea());
      results.push(rebuild(instance));
    }
    return results;
  };

  targetArea = function() {
    return instanceScale * (strategy === "pack" ? shape.packArea() : strategy === "cover" ? shape.coverArea() : shape.packArea());
  };

  shape = shapes[0];

  scrollContainer(0);

  scrollObject(0);

  scrollStrategy(0);

  rebuildAll();

  window.onresize();

  drawLoop();

}).call(this);
